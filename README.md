# Heroes Battle - алгоритмы

Проект содержит реализацию четырёх алгоритмов для игры Heroes Battle.

- **GeneratePreset** - генерация оптимального состава армии компьютера
- **SimulateBattle** - симуляция пошагового боя между армиями
- **SuitableForAttackUnitsFinder** - поиск доступных для атаки юнитов
- **UnitTargetPathFinder** - поиск кратчайшего пути между юнитами

## Реализованные алгоритмы
### 1. GeneratePreset - Генерация армии компьютера

**Файл:** `src/programs/GeneratePresetImpl.java`

**Алгоритм:** Жадный алгоритм с сортировкой по эффективности

**Описание:**
Формирует оптимальный состав армии компьютера на основе соотношения характеристик юнитов к их стоимости.

**Этапы работы:**
1. Вычисление метрики эффективности для каждого типа юнитов:
   - `atkValue = атака / стоимость`
   - `hpValue = здоровье / стоимость`
   - `combinedValue = atkValue × 2.0 + hpValue`
2. Сортировка типов юнитов по убыванию эффективности (insertion sort)
3. Жадный набор юнитов с учётом:
   - Ограничения бюджета (1500 очков)
   - Максимума 11 юнитов каждого типа
4. Случайное размещение юнитов на поле (3×21)

**Ключевые классы:**
- `ArmyBuilder` - главный строитель армии
- `UnitSelector` - выбор юнитов по эффективности
- `ValueMetric` - метрика ценности юнита
- `GridAllocator` - распределение позиций на поле

### 2. SimulateBattle - Симуляция боя

**Файл:** `src/programs/SimulateBattleImpl.java`

**Алгоритм:** Раундовая симуляция с сортировкой по приоритету

**Описание:**
Проводит пошаговый бой между армией игрока и компьютера до победы одной из сторон.

**Этапы работы каждого раунда:**
1. Сбор всех живых юнитов из обеих армий
2. Чередование юнитов (компьютер-игрок-компьютер-игрок)
3. Сортировка по убыванию силы атаки (merge sort)
4. Последовательное выполнение атак всеми юнитами
5. Проверка условия победы после каждой атаки

**Особенности:**
- Юниты с одинаковой силой атаки чередуются между армиями
- Погибшие юниты пропускают ход (проверка `isAlive()`)
- Досрочное завершение раунда при гибели всех юнитов одной армии
- Логирование каждой атаки через `printBattleLog`

**Ключевые классы:**
- `BattleContext` - контекст боя с логикой раундов
- `UnitWithPriority` - обёртка юнита с кэшированной силой атаки

### 3. SuitableForAttackUnitsFinder - Поиск целей для атаки

**Файл:** `src/programs/SuitableForAttackUnitsFinderImpl.java`

**Алгоритм:** Линейный поиск min/max по Y-координате

**Описание:**
Определяет список юнитов противника, доступных для атаки (не закрытых союзниками).

**Логика работы:**
- **Для левой армии (компьютер):** ищет юнитов с минимальной Y-координатой в каждом ряду
- **Для правой армии (игрок):** ищет юнитов с максимальной Y-координатой в каждом ряду

**Этапы работы:**
1. Для каждого ряда (X-координата) отдельно:
2. Линейный проход по всем юнитам в ряду
3. Поиск юнита с экстремальной Y-координатой
4. Добавление найденного юнита в результирующий список

**Ключевые классы:**
- `FrontlineFinder` - поисковик незакрытых юнитов

### 4. UnitTargetPathFinder - Поиск пути

**Файл:** `src/programs/UnitTargetPathFinderImpl.java`

**Алгоритм:** A* с эвристикой Manhattan distance

**Описание:**
Находит кратчайший путь от атакующего юнита до цели на поле с препятствиями.

**Параметры поля:**
- Размер: 27×21 клеток
- Движение: 8 направлений (включая диагонали)
- Препятствия: живые юниты (кроме стартовой и целевой клеток)

**Этапы работы:**
1. Построение карты препятствий из живых юнитов
2. Инициализация стартового узла в приоритетной очереди
3. Основной цикл A*:
   - Извлечение узла с минимальной f-стоимостью
   - Проверка достижения цели
   - Раскрытие соседних узлов
   - Обновление g-стоимостей и родителей
4. Восстановление пути от цели к старту
5. Разворот пути в правильном направлении

**Ключевые классы:**
- `PathfindingContext` - контекст поиска (старт, цель, эвристика)
- `ObstacleMap` - карта препятствий с битовым кодированием координат
- `AStarSolver` - решатель A* с приоритетной очередью
- `SearchNode` - узел поиска (x, y, g, f, parent)

---

## Сложность

### 1. GeneratePreset

**Реализация:** O(n²)

**Анализ:**
```
n = количество типов юнитов (4)
m = максимум юнитов одного типа (11)

1. Вычисление метрик: O(n)
2. Insertion sort: O(n²) → для n=4: O(16) ≈ константа
3. Выбор количеств: O(n)
4. Создание юнитов: O(total) ≤ O(n×11)

Итого: O(n) + O(n²) + O(n) + O(n×11) = O(n²)
```

---

### 2. SimulateBattle

**Реализация:** O(n² log n)

**Анализ:**
```
n = общее количество юнитов

1. Количество раундов: O(n) в худшем случае
2. Каждый раунд:
   - Сбор живых юнитов: O(n)
   - Merge sort: O(n log n)
   - Выполнение атак: O(n)

Один раунд: O(n) + O(n log n) + O(n) = O(n log n)
Всего раундов: O(n)

Итого: O(n × n log n) = O(n² log n)
```

---

### 3. SuitableForAttackUnitsFinder

**Реализация:** O(n)

**Анализ:**
```
m = 3 (количество рядов - константа)
n = общее количество юнитов

1. Внешний цикл по рядам: O(m) = O(3) = O(1)
2. Внутренний цикл по юнитам в ряду: O(n/m)

Итого: O(m × n/m) = O(n)
```


### 4. UnitTargetPathFinder

**Реализация:** O((W×H) × log(W×H))

**Анализ:**
```
W = 27 (ширина поля)
H = 21 (высота поля)
V = W×H = 567 (количество вершин)

1. A* с PriorityQueue:
   - Операции с очередью: O(log V) каждая
   - В худшем случае посещаем все вершины: O(V)
   - Проверка 8 соседей: O(8) = O(1)

Итого: O(V × log V) = O((W×H) × log(W×H))

Для 27×21: O(567 × log 567) ≈ O(567 × 9.15) ≈ O(5188)
```

## Установка и запуск

### Компиляция

```bash
javac -source 8 -target 8 \
  -cp "libs/heroes_task_lib-1.0-SNAPSHOT.jar" \
  -d out/production \
  src/programs/*.java
```

### Создание JAR

```bash
jar -cvf heroes_student_task.jar -C out/production .
```

### Запуск игры

1. Скопировать `heroes_student_task.jar` в `heroes/jars/`
2. Запустить игру:

```bash
java -jar "heroes/Heroes Battle-1.0.0.jar"
```